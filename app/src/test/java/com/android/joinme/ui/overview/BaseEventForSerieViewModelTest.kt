package com.android.joinme.ui.overview

import android.content.Context
import android.net.Uri
import com.android.joinme.model.event.Event
import com.android.joinme.model.event.EventType
import com.android.joinme.model.groups.Group
import com.android.joinme.model.groups.GroupRepository
import com.android.joinme.model.map.Location
import com.android.joinme.model.map.LocationRepository
import com.android.joinme.model.serie.Serie
import com.android.joinme.model.serie.SerieFilter
import com.android.joinme.model.serie.SeriesRepository
import com.google.firebase.Timestamp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

/** Note: The tests were generated by IA (Claude) */

/**
 * Unit tests for BaseEventForSerieViewModel.
 *
 * Tests the shared validation and location logic for event for serie forms, including:
 * - Field validation (type, title, description, duration, location)
 * - Location search and selection
 * - Error message handling
 */
@OptIn(ExperimentalCoroutinesApi::class)
class BaseEventForSerieViewModelTest {

  // ---- Test ViewModel ----
  // Uses EventForSerieFormState directly for testing
  private class TestEventForSerieViewModel(
      locationRepository: LocationRepository,
      serieRepository: SeriesRepository,
      groupRepository: GroupRepository
  ) : BaseEventForSerieViewModel(locationRepository, serieRepository, groupRepository) {

    override val _uiState = MutableStateFlow(EventForSerieFormState())
    val uiState = _uiState

    override fun getState(): EventForSerieFormUIState = _uiState.value

    override fun updateState(transform: (EventForSerieFormUIState) -> EventForSerieFormUIState) {
      _uiState.value = transform(_uiState.value) as EventForSerieFormState
    }

    // Expose for testing
    fun testSetErrorMsg(msg: String) = setErrorMsg(msg)

    // Expose updateState for testing
    fun testUpdateState(transform: (EventForSerieFormUIState) -> EventForSerieFormUIState) {
      updateState(transform)
    }

    // Expose protected methods for testing
    suspend fun testLoadSerieAndCheckGroup(serieId: String) = loadSerieAndCheckGroup(serieId)

    suspend fun testDetermineEventTypeFromGroup(serie: Serie) = determineEventTypeFromGroup(serie)

    fun testPopulateEventData(
        event: Event,
        serieHasGroup: Boolean = false,
        preservedType: String? = null
    ) = populateEventData(event, serieHasGroup, preservedType)
  }

  // ---- Fake Repositories ----
  private class FakeLocationRepository : LocationRepository {
    var shouldThrowError = false

    override suspend fun search(query: String): List<Location> {
      if (shouldThrowError) throw RuntimeException("Network error")
      return if (query.isBlank()) {
        emptyList()
      } else {
        listOf(
            Location(latitude = 1.0, longitude = 1.0, name = "Test Location 1"),
            Location(latitude = 2.0, longitude = 2.0, name = "Test Location 2"),
            Location(latitude = 3.0, longitude = 3.0, name = "$query Stadium"))
      }
    }
  }

  private class FakeSeriesRepository : SeriesRepository {
    private val series = mutableMapOf<String, Serie>()
    var shouldThrowError = false

    fun addTestSerie(serie: Serie) {
      series[serie.serieId] = serie
    }

    override suspend fun getSerie(serieId: String): Serie {
      if (shouldThrowError) throw RuntimeException("Network error")
      return series[serieId] ?: throw NoSuchElementException("Serie not found: $serieId")
    }

    override suspend fun editSerie(serieId: String, serie: Serie) = throw NotImplementedError()

    override suspend fun addSerie(serie: Serie) = throw NotImplementedError()

    override suspend fun deleteSerie(serieId: String) = throw NotImplementedError()

    override suspend fun getAllSeries(filter: SerieFilter): List<Serie> = series.values.toList()

    override suspend fun getSeriesByIds(seriesIds: List<String>): List<Serie> = emptyList()

    override fun getNewSerieId(): String = "newSerieId"
  }

  private class FakeGroupRepository : GroupRepository {
    private val groups = mutableMapOf<String, Group>()
    var shouldThrowError = false

    fun addTestGroup(group: Group) {
      groups[group.id] = group
    }

    override suspend fun getGroup(groupId: String): Group {
      if (shouldThrowError) throw RuntimeException("Network error")
      return groups[groupId] ?: throw NoSuchElementException("Group not found: $groupId")
    }

    override suspend fun getAllGroups(): List<Group> = groups.values.toList()

    override suspend fun addGroup(group: Group) = throw NotImplementedError()

    override suspend fun deleteGroup(groupId: String, userId: String) = throw NotImplementedError()

    override suspend fun leaveGroup(groupId: String, userId: String) = throw NotImplementedError()

    override suspend fun joinGroup(groupId: String, userId: String) = throw NotImplementedError()

    override suspend fun editGroup(groupId: String, group: Group) = throw NotImplementedError()

    override suspend fun getCommonGroups(userIds: List<String>): List<Group> = emptyList()

    override fun getNewGroupId(): String = "newGroupId"

    override suspend fun uploadGroupPhoto(
        context: Context,
        groupId: String,
        imageUri: Uri
    ): String {
      // Not needed for these tests
      return "http://fakeurl.com/photo.jpg"
    }

    override suspend fun deleteGroupPhoto(groupId: String) {
      // Not needed for these tests
    }
  }

  private lateinit var locationRepo: FakeLocationRepository
  private lateinit var serieRepo: FakeSeriesRepository
  private lateinit var groupRepo: FakeGroupRepository
  private lateinit var vm: TestEventForSerieViewModel
  private val testDispatcher = StandardTestDispatcher()

  @Before
  fun setUp() {
    Dispatchers.setMain(testDispatcher)
    locationRepo = FakeLocationRepository()
    serieRepo = FakeSeriesRepository()
    groupRepo = FakeGroupRepository()
    vm = TestEventForSerieViewModel(locationRepo, serieRepo, groupRepo)
  }

  @After
  fun tearDown() {
    Dispatchers.resetMain()
  }

  // ---------- Type validation ----------

  @Test
  fun setType_blank_setsInvalidTypeMsg() {
    vm.setType("")
    val state = vm.uiState.value
    assertNotNull(state.invalidTypeMsg)
    assertTrue(state.invalidTypeMsg!!.contains("cannot be empty"))
  }

  @Test
  fun setType_invalid_setsInvalidTypeMsg() {
    vm.setType("INVALID_TYPE")
    val state = vm.uiState.value
    assertNotNull(state.invalidTypeMsg)
  }

  @Test
  fun setType_validSports_clearsInvalidTypeMsg() {
    vm.setType("SPORTS")
    val state = vm.uiState.value
    assertEquals("SPORTS", state.type)
    assertNull(state.invalidTypeMsg)
  }

  @Test
  fun setType_validActivity_clearsInvalidTypeMsg() {
    vm.setType("ACTIVITY")
    val state = vm.uiState.value
    assertEquals("ACTIVITY", state.type)
    assertNull(state.invalidTypeMsg)
  }

  @Test
  fun setType_validSocial_clearsInvalidTypeMsg() {
    vm.setType("SOCIAL")
    val state = vm.uiState.value
    assertEquals("SOCIAL", state.type)
    assertNull(state.invalidTypeMsg)
  }

  @Test
  fun setType_caseInsensitive_works() {
    vm.setType("sports")
    val state = vm.uiState.value
    assertEquals("sports", state.type)
    assertNull(state.invalidTypeMsg)
  }

  // ---------- Title validation ----------

  @Test
  fun setTitle_blank_setsInvalidTitleMsg() {
    vm.setTitle("")
    val state = vm.uiState.value
    assertNotNull(state.invalidTitleMsg)
    assertTrue(state.invalidTitleMsg!!.contains("cannot be empty"))
  }

  @Test
  fun setTitle_nonBlank_updatesTitle() {
    vm.setTitle("Weekly Soccer Match")
    val state = vm.uiState.value
    assertEquals("Weekly Soccer Match", state.title)
    assertNull(state.invalidTitleMsg)
  }

  @Test
  fun setTitle_withSpaces_updatesTitle() {
    vm.setTitle("   Match with spaces   ")
    val state = vm.uiState.value
    assertEquals("   Match with spaces   ", state.title)
    assertNull(state.invalidTitleMsg)
  }

  // ---------- Description validation ----------

  @Test
  fun setDescription_blank_setsInvalidDescriptionMsg() {
    vm.setDescription("")
    val state = vm.uiState.value
    assertNotNull(state.invalidDescriptionMsg)
    assertTrue(state.invalidDescriptionMsg!!.contains("cannot be empty"))
  }

  @Test
  fun setDescription_multiline_updatesDescription() {
    val multiline = "First line\nSecond line\nThird line"
    vm.setDescription(multiline)
    val state = vm.uiState.value
    assertEquals(multiline, state.description)
    assertNull(state.invalidDescriptionMsg)
  }

  // ---------- Duration validation ----------

  @Test
  fun setDuration_empty_setsInvalidDurationMsg() {
    vm.setDuration("")
    val state = vm.uiState.value
    assertNotNull(state.invalidDurationMsg)
  }

  @Test
  fun setDuration_notANumber_setsInvalidDurationMsg() {
    vm.setDuration("ninety")
    val state = vm.uiState.value
    assertNotNull(state.invalidDurationMsg)
  }

  @Test
  fun setDuration_positiveNumber_noError() {
    vm.setDuration("90")
    val state = vm.uiState.value
    assertEquals("90", state.duration)
    assertNull(state.invalidDurationMsg)
  }

  // ---------- Location validation ----------

  @Test
  fun setLocation_blank_setsInvalidLocationMsg() {
    vm.setLocation("")
    val state = vm.uiState.value
    assertNotNull(state.invalidLocationMsg)
    assertTrue(state.invalidLocationMsg!!.contains("valid Location"))
  }

  @Test
  fun setLocation_nonBlank_updatesLocation() {
    vm.setLocation("Stadium")
    val state = vm.uiState.value
    assertEquals("Stadium", state.location)
    assertNull(state.invalidLocationMsg)
  }

  @Test
  fun setLocation_blankClearsSelectedLocation() {
    // First set a location
    val loc = Location(latitude = 1.0, longitude = 1.0, name = "Stadium")
    vm.selectLocation(loc)
    assertEquals(loc, vm.uiState.value.selectedLocation)

    // Then set blank location
    vm.setLocation("")
    val state = vm.uiState.value
    assertNull(state.selectedLocation)
  }

  // ---------- Location query ----------

  @Test
  fun setLocationQuery_updatesQuery() {
    vm.setLocationQuery("Stadium")
    val state = vm.uiState.value
    assertEquals("Stadium", state.locationQuery)
  }

  @Test
  fun setLocationQuery_emptyString_updatesQuery() {
    vm.setLocationQuery("")
    val state = vm.uiState.value
    assertEquals("", state.locationQuery)
  }

  // ---------- Location search ----------

  @Test
  fun searchLocations_blank_returnsEmpty() = runTest {
    vm.searchLocations("")
    advanceUntilIdle()

    val state = vm.uiState.value
    assertTrue(state.locationSuggestions.isEmpty())
  }

  @Test
  fun searchLocations_nonBlank_returnsSuggestions() = runTest {
    vm.searchLocations("Stadium")
    advanceUntilIdle()

    val state = vm.uiState.value
    assertTrue(state.locationSuggestions.isNotEmpty())
    assertEquals(3, state.locationSuggestions.size)
  }

  @Test
  fun searchLocations_error_returnsEmpty() = runTest {
    locationRepo.shouldThrowError = true
    vm.searchLocations("Stadium")
    advanceUntilIdle()

    val state = vm.uiState.value
    assertTrue(state.locationSuggestions.isEmpty())
  }

  @Test
  fun searchLocations_multipleQueries_updatesResults() = runTest {
    vm.searchLocations("First")
    advanceUntilIdle()
    assertEquals(3, vm.uiState.value.locationSuggestions.size)

    vm.searchLocations("Second")
    advanceUntilIdle()
    assertEquals(3, vm.uiState.value.locationSuggestions.size)
  }

  // ---------- Location selection ----------

  @Test
  fun selectLocation_updatesAllLocationFields() {
    val loc = Location(latitude = 46.52, longitude = 6.57, name = "EPFL")
    vm.selectLocation(loc)

    val state = vm.uiState.value
    assertEquals(loc, state.selectedLocation)
    assertEquals("EPFL", state.location)
    assertEquals("EPFL", state.locationQuery)
    assertTrue(state.locationSuggestions.isEmpty())
    assertNull(state.invalidLocationMsg)
  }

  @Test
  fun selectLocation_clearsSuggestions() = runTest {
    vm.searchLocations("Stadium")
    advanceUntilIdle()
    assertTrue(vm.uiState.value.locationSuggestions.isNotEmpty())

    val loc = Location(latitude = 1.0, longitude = 1.0, name = "Stadium")
    vm.selectLocation(loc)

    assertTrue(vm.uiState.value.locationSuggestions.isEmpty())
  }

  @Test
  fun selectLocation_differentLocation_updatesCorrectly() {
    val loc1 = Location(latitude = 1.0, longitude = 1.0, name = "Stadium 1")
    vm.selectLocation(loc1)
    assertEquals(loc1, vm.uiState.value.selectedLocation)

    val loc2 = Location(latitude = 2.0, longitude = 2.0, name = "Stadium 2")
    vm.selectLocation(loc2)
    assertEquals(loc2, vm.uiState.value.selectedLocation)
    assertEquals("Stadium 2", vm.uiState.value.location)
  }

  // ---------- Clear location ----------

  @Test
  fun clearLocation_resetsAllLocationFields() {
    val loc = Location(latitude = 1.0, longitude = 1.0, name = "Stadium")
    vm.selectLocation(loc)

    vm.clearLocation()

    val state = vm.uiState.value
    assertNull(state.selectedLocation)
    assertEquals("", state.location)
    assertEquals("", state.locationQuery)
    assertNotNull(state.invalidLocationMsg)
  }

  // ---------- Error handling ----------

  @Test
  fun setErrorMsg_setsError_andClearErrorMsg_clearsIt() {
    // Set error and verify it's set
    vm.testSetErrorMsg("Custom error message")
    assertEquals("Custom error message", vm.uiState.value.errorMsg)

    // Clear error and verify it's cleared
    vm.clearErrorMsg()
    assertNull(vm.uiState.value.errorMsg)
  }

  // ---------- Integration tests ----------

  @Test
  fun fullFlow_searchSelectAndFillForm() = runTest {
    // Set type
    vm.setType("SPORTS")
    assertEquals("SPORTS", vm.uiState.value.type)
    assertNull(vm.uiState.value.invalidTypeMsg)

    // Set title
    vm.setTitle("Weekly Match")
    assertEquals("Weekly Match", vm.uiState.value.title)
    assertNull(vm.uiState.value.invalidTitleMsg)

    // Set description
    vm.setDescription("Weekly soccer match")
    assertEquals("Weekly soccer match", vm.uiState.value.description)
    assertNull(vm.uiState.value.invalidDescriptionMsg)

    // Set duration
    vm.setDuration("90")
    assertEquals("90", vm.uiState.value.duration)
    assertNull(vm.uiState.value.invalidDurationMsg)

    // Search and select location
    vm.setLocationQuery("Stadium")
    vm.searchLocations("Stadium")
    advanceUntilIdle()
    assertTrue(vm.uiState.value.locationSuggestions.isNotEmpty())

    val location = vm.uiState.value.locationSuggestions.first()
    vm.selectLocation(location)
    assertEquals(location, vm.uiState.value.selectedLocation)
    assertNull(vm.uiState.value.invalidLocationMsg)

    // Verify all validation messages are null
    val state = vm.uiState.value
    assertNull(state.invalidTypeMsg)
    assertNull(state.invalidTitleMsg)
    assertNull(state.invalidDescriptionMsg)
    assertNull(state.invalidDurationMsg)
    assertNull(state.invalidLocationMsg)
  }

  @Test
  fun invalidForm_hasValidationMessages() {
    vm.setType("")
    vm.setTitle("")
    vm.setDescription("")
    vm.setDuration("-10")
    vm.setLocation("")

    val state = vm.uiState.value
    assertNotNull(state.invalidTypeMsg)
    assertNotNull(state.invalidTitleMsg)
    assertNotNull(state.invalidDescriptionMsg)
    assertNotNull(state.invalidDurationMsg)
    assertNotNull(state.invalidLocationMsg)
  }

  @Test
  fun locationWorkflow_querySearchSelectClear() = runTest {
    // Query
    vm.setLocationQuery("Test")
    assertEquals("Test", vm.uiState.value.locationQuery)

    // Search
    vm.searchLocations("Test")
    advanceUntilIdle()
    assertTrue(vm.uiState.value.locationSuggestions.isNotEmpty())

    // Select
    val location = vm.uiState.value.locationSuggestions.first()
    vm.selectLocation(location)
    assertEquals(location, vm.uiState.value.selectedLocation)

    // Clear
    vm.clearLocation()
    assertNull(vm.uiState.value.selectedLocation)
    assertEquals("", vm.uiState.value.locationQuery)
  }

  // ---------- isValid with serieHasGroup tests ----------

  @Test
  fun isValid_withSerieHasGroupTrue_doesNotRequireType() = runTest {
    // Simulate serie with group (type not required)
    val stateWithGroup = EventForSerieFormState(serieHasGroup = true, type = "")
    vm.testUpdateState { stateWithGroup }

    // Fill all other required fields
    vm.setTitle("Event Title")
    vm.setDescription("Event Description")
    vm.setDuration("90")
    vm.selectLocation(Location(latitude = 1.0, longitude = 1.0, name = "Stadium"))

    // Verify form is valid even without type field being manually set
    val state = vm.uiState.value
    assertTrue(state.serieHasGroup)
    assertTrue(state.isValid) // Should be valid without explicit type
    assertNull(state.invalidTitleMsg)
    assertNull(state.invalidDescriptionMsg)
    assertNull(state.invalidDurationMsg)
    assertNull(state.invalidLocationMsg)
  }

  @Test
  fun isValid_withSerieHasGroupFalse_requiresType() = runTest {
    // Simulate standalone serie (type required)
    val stateWithoutGroup = EventForSerieFormState(serieHasGroup = false, type = "")
    vm.testUpdateState { stateWithoutGroup }

    // Fill all fields EXCEPT type
    vm.setTitle("Event Title")
    vm.setDescription("Event Description")
    vm.setDuration("90")
    vm.selectLocation(Location(latitude = 1.0, longitude = 1.0, name = "Stadium"))

    // Verify form is NOT valid without type
    val stateBeforeType = vm.uiState.value
    assertFalse(stateBeforeType.serieHasGroup)
    assertFalse(stateBeforeType.isValid) // Not valid without type

    // Now add type
    vm.setType("SPORTS")

    // Verify form is now valid
    val stateAfterType = vm.uiState.value
    assertTrue(stateAfterType.isValid)
    assertEquals("SPORTS", stateAfterType.type)
    assertNull(stateAfterType.invalidTypeMsg)
  }

  // ---------- populateEventData tests ----------

  @Test
  fun populateEventData_standaloneVsGroupSerie_handlesTypeCorrectly() {
    val location = Location(latitude = 46.52, longitude = 6.57, name = "EPFL")
    val event =
        Event(
            eventId = "event1",
            type = EventType.ACTIVITY,
            title = "Test Event",
            description = "Test Description",
            location = location,
            date = Timestamp.now(),
            duration = 120,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = com.android.joinme.model.event.EventVisibility.PUBLIC,
            ownerId = "user1")

    // Part 1: Standalone event - uses event's type
    vm.testPopulateEventData(event)

    var state = vm.uiState.value
    assertEquals("ACTIVITY", state.type)
    assertEquals("Test Event", state.title)
    assertEquals("Test Description", state.description)
    assertEquals("EPFL", state.location)
    assertEquals("120", state.duration)

    // Part 2: Group serie event - preserves group type
    vm.testPopulateEventData(event, serieHasGroup = true, preservedType = "SPORTS")

    state = vm.uiState.value
    assertEquals("SPORTS", state.type) // Preserved from group, not ACTIVITY
    assertEquals("Test Event", state.title)
    assertEquals("Test Description", state.description)
    assertEquals("EPFL", state.location)
    assertEquals("120", state.duration)

    // Part 3: Event with null location
    val eventNoLocation =
        Event(
            eventId = "event2",
            type = EventType.SOCIAL,
            title = "No Location Event",
            description = "Desc",
            location = null,
            date = Timestamp.now(),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = com.android.joinme.model.event.EventVisibility.PRIVATE,
            ownerId = "user1")

    vm.testPopulateEventData(eventNoLocation)

    state = vm.uiState.value
    assertEquals("SOCIAL", state.type)
    assertEquals("", state.location)
    assertEquals("", state.locationQuery)
    assertNull(state.selectedLocation)
  }

  // ---------- loadSerieAndCheckGroup tests ----------

  @Test
  fun loadSerieAndCheckGroup_withNonexistentSerie_setsErrorMsg() = runTest {
    // Try to load a serie that doesn't exist
    vm.testLoadSerieAndCheckGroup("nonexistent-serie")
    advanceUntilIdle()

    // Verify error message is set and contains expected text
    val state = vm.uiState.value
    assertNotNull(state.errorMsg)
    assertTrue(state.errorMsg!!.contains("Failed to load serie"))
  }

  @Test
  fun loadSerieAndCheckGroup_withMissingGroup_setsErrorMsg() = runTest {
    // Create a serie with a groupId that doesn't exist in the repository
    val serie =
        Serie(
            serieId = "serie-with-missing-group",
            title = "Orphaned Serie",
            description = "Group doesn't exist",
            date = Timestamp.now(),
            participants = listOf("owner-1"),
            maxParticipants = 20,
            visibility = com.android.joinme.model.utils.Visibility.PUBLIC,
            eventIds = emptyList(),
            ownerId = "owner-1",
            groupId = "nonexistent-group") // Group doesn't exist

    serieRepo.addTestSerie(serie)

    // Try to load the serie
    vm.testLoadSerieAndCheckGroup("serie-with-missing-group")
    advanceUntilIdle()

    // Verify error message is set and contains expected text
    val state = vm.uiState.value
    assertNotNull(state.errorMsg)
    assertTrue(state.errorMsg!!.contains("Group not found"))
  }
}
