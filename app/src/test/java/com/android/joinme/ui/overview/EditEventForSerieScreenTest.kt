package com.android.joinme.ui.overview

import android.content.Context
import android.net.Uri
import androidx.compose.ui.semantics.SemanticsProperties
import androidx.compose.ui.semantics.getOrNull
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createComposeRule
import com.android.joinme.model.event.Event
import com.android.joinme.model.event.EventFilter
import com.android.joinme.model.event.EventType
import com.android.joinme.model.event.EventVisibility
import com.android.joinme.model.event.EventsRepository
import com.android.joinme.model.groups.Group
import com.android.joinme.model.groups.GroupRepository
import com.android.joinme.model.map.Location
import com.android.joinme.model.serie.Serie
import com.android.joinme.model.serie.SerieFilter
import com.android.joinme.model.serie.SeriesRepository
import com.android.joinme.model.utils.Visibility
import com.google.firebase.Timestamp
import java.util.*
import kotlinx.coroutines.runBlocking
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner
import org.robolectric.annotation.Config

/** Note: This file was generated by AI (Claude) */
@RunWith(RobolectricTestRunner::class)
@Config(sdk = [28], qualifiers = "w360dp-h640dp-normal-long-notround-any-420dpi-keyshidden-nonav")
class EditEventForSerieScreenTest {

  @get:Rule val composeTestRule = createComposeRule()

  // Fake repositories for testing
  private class FakeEventsRepository : EventsRepository {
    private val events = mutableMapOf<String, Event>()

    fun addTestEvent(event: Event) {
      events[event.eventId] = event
    }

    override suspend fun getEvent(eventId: String): Event {
      return events[eventId] ?: throw NoSuchElementException("Event not found")
    }

    override suspend fun getAllEvents(filter: EventFilter): List<Event> {
      return events.values.toList()
    }

    override suspend fun editEvent(eventId: String, event: Event) {
      events[eventId] = event
    }

    override suspend fun addEvent(event: Event) {
      events[event.eventId] = event
    }

    override fun getNewEventId(): String = "newId"

    override suspend fun deleteEvent(eventId: String) {
      events.remove(eventId)
    }

    override suspend fun getEventsByIds(eventIds: List<String>): List<Event> {
      events
          .filter { eventIds.contains(it.key) }
          .let {
            return it.values.toList()
          }
    }

    override suspend fun getCommonEvents(userIds: List<String>): List<Event> {
      if (userIds.isEmpty()) return emptyList()
      return events.values
          .filter { event -> userIds.all { userId -> event.participants.contains(userId) } }
          .sortedBy { it.date.toDate().time }
    }
  }

  private class FakeSeriesRepository : SeriesRepository {
    private val series = mutableMapOf<String, Serie>()

    fun addTestSerie(serie: Serie) {
      series[serie.serieId] = serie
    }

    override suspend fun getSerie(serieId: String): Serie {
      return series[serieId] ?: throw NoSuchElementException("Serie not found")
    }

    override suspend fun getAllSeries(serieFilter: SerieFilter): List<Serie> =
        series.values.toList()

    override suspend fun getSeriesByIds(seriesIds: List<String>): List<Serie> {
      return series
          .filter { seriesIds.contains(it.key) }
          .let {
            return it.values.toList()
          }
    }

    override suspend fun addSerie(serie: Serie) {
      series[serie.serieId] = serie
    }

    override suspend fun editSerie(serieId: String, serie: Serie) {
      series[serieId] = serie
    }

    override fun getNewSerieId(): String = "newSerieId"

    override suspend fun deleteSerie(serieId: String) {
      series.remove(serieId)
    }
  }

  private class FakeGroupRepository : GroupRepository {
    private val groups = mutableMapOf<String, Group>()

    fun addTestGroup(group: Group) {
      groups[group.id] = group
    }

    override suspend fun getGroup(groupId: String): Group {
      return groups[groupId] ?: throw NoSuchElementException("Group not found")
    }

    override suspend fun getAllGroups(): List<Group> = groups.values.toList()

    override suspend fun addGroup(group: Group) {
      groups[group.id] = group
    }

    override suspend fun deleteGroup(groupId: String, userId: String) {
      groups.remove(groupId)
    }

    override suspend fun leaveGroup(groupId: String, userId: String) {}

    override suspend fun joinGroup(groupId: String, userId: String) {}

    override suspend fun editGroup(groupId: String, group: Group) {
      groups[groupId] = group
    }

    override suspend fun getCommonGroups(userIds: List<String>): List<Group> = emptyList()

    override fun getNewGroupId(): String = "newGroupId"

    override suspend fun uploadGroupPhoto(
        context: Context,
        groupId: String,
        imageUri: Uri
    ): String {
      // Not needed for these tests
      return "http://fakeurl.com/photo.jpg"
    }

    override suspend fun deleteGroupPhoto(groupId: String) {
      // Not needed for these tests
    }
  }

  private fun createTestEvent(): Event {
    val calendar = Calendar.getInstance()
    calendar.set(2025, Calendar.DECEMBER, 25, 14, 30, 0)

    return Event(
        eventId = "test-event-1",
        ownerId = "owner123",
        title = "Weekly Football",
        type = EventType.SPORTS,
        description = "Weekly football game",
        location = Location(46.52, 6.63, "EPFL Field"),
        date = Timestamp(calendar.time),
        duration = 60,
        maxParticipants = 10,
        participants = listOf("owner123"),
        visibility = EventVisibility.PUBLIC)
  }

  private fun createTestSerie(): Serie {
    val calendar = Calendar.getInstance()
    calendar.set(2025, Calendar.DECEMBER, 25, 14, 30, 0)

    return Serie(
        serieId = "test-serie-1",
        title = "Weekly Football",
        description = "Weekly football series",
        date = Timestamp(calendar.time),
        participants = listOf("owner123"),
        maxParticipants = 10,
        visibility = Visibility.PUBLIC,
        eventIds = listOf("test-event-1"),
        ownerId = "owner123")
  }

  /** Helper to setup the screen with default parameters */
  private fun setupScreen() {
    composeTestRule.setContent {
      EditEventForSerieScreen(serieId = "testSerieId", eventId = "testEventId", onDone = {})
    }
  }

  /** --- BASIC RENDERING AND DISPLAY --- */
  @Test
  fun basicRendering_allFieldsButtonsAndTextsAreDisplayed() {
    setupScreen()

    // All fields are displayed
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TYPE)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TITLE)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_DESCRIPTION)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_DURATION)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_LOCATION)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.BUTTON_SAVE_EVENT)
        .assertIsDisplayed()

    // Title and button text are correct
    composeTestRule.onNodeWithText("Edit Event for Serie").assertIsDisplayed()
    composeTestRule.onNodeWithText("SAVE CHANGES").assertIsDisplayed()

    // Fields inherited from serie are not displayed
    composeTestRule
        .onNodeWithTag("inputEventMaxParticipants", useUnmergedTree = true)
        .assertDoesNotExist()
    composeTestRule.onNodeWithTag("inputEventDate", useUnmergedTree = true).assertDoesNotExist()
    composeTestRule.onNodeWithTag("inputEventTime", useUnmergedTree = true).assertDoesNotExist()
    composeTestRule
        .onNodeWithTag("inputEventVisibility", useUnmergedTree = true)
        .assertDoesNotExist()
  }

  /** --- INPUT BEHAVIOR --- */
  @Test
  fun inputBehavior_typeDropdownAndAllTypesAvailable() {
    setupScreen()

    // Click on type dropdown
    composeTestRule.onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TYPE).performClick()

    // All event types are available
    composeTestRule.onNodeWithText("SPORTS").assertIsDisplayed()
    composeTestRule.onNodeWithText("ACTIVITY").assertIsDisplayed()
    composeTestRule.onNodeWithText("SOCIAL").assertIsDisplayed()

    // Select SPORTS
    composeTestRule.onNodeWithText("SPORTS").performClick()

    // Verify selection
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TYPE)
        .assertTextContains("SPORTS")
  }

  @Test
  fun inputBehavior_textFieldsAcceptInput() {
    setupScreen()

    val title = "Updated Football Match"
    val desc = "Updated description"
    val location = "New Location"

    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TITLE)
        .performTextClearance()
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TITLE)
        .performTextInput(title)

    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_DESCRIPTION)
        .performTextClearance()
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_DESCRIPTION)
        .performTextInput(desc)

    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_LOCATION)
        .performTextClearance()
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_LOCATION)
        .performTextInput(location)

    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TITLE)
        .assertTextContains(title)
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_DESCRIPTION)
        .assertTextContains(desc)
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_LOCATION)
        .assertTextContains(location)
  }

  @Test
  fun inputBehavior_switchingTypeRetainsOtherFields() {
    setupScreen()

    val title = "Morning Run"
    val desc = "Light jog near EPFL"

    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TITLE)
        .performTextClearance()
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TITLE)
        .performTextInput(title)

    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_DESCRIPTION)
        .performTextClearance()
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_DESCRIPTION)
        .performTextInput(desc)

    composeTestRule.onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TYPE).performClick()
    composeTestRule.onNodeWithText("SPORTS").performClick()

    composeTestRule.onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TYPE).performClick()
    composeTestRule.onNodeWithText("SOCIAL").performClick()

    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TITLE)
        .assertTextContains(title)
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_DESCRIPTION)
        .assertTextContains(desc)
  }

  @Test
  fun inputBehavior_durationPickerOpensAndSelectsValue() {
    setupScreen()

    // Opens on click
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_DURATION)
        .performClick()

    composeTestRule.onNodeWithText("Select Duration (min)").assertIsDisplayed()

    // Selects value
    composeTestRule.onNodeWithText("OK").performClick()

    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_DURATION)
        .assertExists()
  }

  @Test
  fun inputBehavior_locationFieldAcceptsInput() {
    setupScreen()

    val location = "Rolex Learning Center"
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_LOCATION)
        .performTextClearance()
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_LOCATION)
        .performTextInput(location)

    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_LOCATION)
        .assertTextContains(location)
  }

  @Test
  fun inputBehavior_locationSelectionTriggersViewModel() {
    setupScreen()

    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_LOCATION)
        .performTextInput("EPFL")

    composeTestRule.waitForIdle()
  }

  /** --- VALIDATION BEHAVIOR --- */
  @Test
  fun validation_emptyTitleDisablesSaveButton() {
    setupScreen()

    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TITLE)
        .performTextClearance()

    composeTestRule.waitForIdle()
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.BUTTON_SAVE_EVENT)
        .assertIsNotEnabled()
  }

  @Test
  fun validation_whitespaceInputsTreatedAsEmpty() {
    setupScreen()

    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TITLE)
        .performTextClearance()
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TITLE)
        .performTextInput("   ")

    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_DESCRIPTION)
        .performTextClearance()
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_DESCRIPTION)
        .performTextInput("   ")

    composeTestRule.waitForIdle()
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.BUTTON_SAVE_EVENT)
        .assertIsNotEnabled()
  }

  /** --- PARAMETER PASSING --- */
  @Test
  fun parameters_eventIdAndSerieIdPassedCorrectly() {
    val testSerieId = "unique-serie-id-123"
    val testEventId = "unique-event-id-456"

    composeTestRule.setContent {
      EditEventForSerieScreen(serieId = testSerieId, eventId = testEventId, onDone = {})
    }

    composeTestRule.onNodeWithTag(EditEventForSerieScreenTestTags.BUTTON_SAVE_EVENT).assertExists()
  }

  /** --- SAVE FUNCTIONALITY --- */
  @Test
  fun save_clickingWithValidDataCallsOnDone() {
    val eventRepo = FakeEventsRepository()
    val serieRepo = FakeSeriesRepository()
    val event = createTestEvent()
    val serie = createTestSerie()

    runBlocking {
      eventRepo.addTestEvent(event)
      serieRepo.addTestSerie(serie)
    }

    val viewModel = EditEventForSerieViewModel(eventRepo, serieRepo)
    var saveCalled = false

    composeTestRule.setContent {
      EditEventForSerieScreen(
          serieId = serie.serieId,
          eventId = event.eventId,
          editEventForSerieViewModel = viewModel,
          onDone = { saveCalled = true })
    }

    composeTestRule.waitForIdle()
    composeTestRule.mainClock.advanceTimeBy(2000)
    composeTestRule.waitForIdle()

    // Wait for button to be enabled (event data should be loaded)
    composeTestRule.waitUntil(timeoutMillis = 5_000) {
      composeTestRule
          .onAllNodesWithTag(EditEventForSerieScreenTestTags.BUTTON_SAVE_EVENT)
          .fetchSemanticsNodes()
          .firstOrNull()
          ?.config
          ?.getOrNull(SemanticsProperties.Disabled) == null
    }

    // Click save
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.BUTTON_SAVE_EVENT)
        .performScrollTo()
        .performClick()

    composeTestRule.waitForIdle()
    composeTestRule.mainClock.advanceTimeBy(1000)

    // Assert callback called
    assert(saveCalled)
  }

  /** --- GROUP SERIE EVENT EDITING TESTS --- */

  // Helper to create test data and setup screen
  private fun setupGroupSerieEventScreen(
      eventType: EventType,
      groupId: String,
      serieId: String,
      eventId: String
  ): Triple<FakeEventsRepository, FakeSeriesRepository, FakeGroupRepository> {
    val eventRepo = FakeEventsRepository()
    val serieRepo = FakeSeriesRepository()
    val groupRepo = FakeGroupRepository()

    val calendar = Calendar.getInstance()
    calendar.set(2025, Calendar.DECEMBER, 25, 14, 30, 0)

    // Create group
    val group =
        Group(
            id = groupId,
            name = "${eventType.name} Group",
            category = eventType,
            description = "${eventType.name} group",
            ownerId = "owner1",
            memberIds = listOf("owner1", "user1"))
    groupRepo.addTestGroup(group)

    // Create serie with group
    val serie =
        Serie(
            serieId = serieId,
            title = "Group Serie",
            description = "Serie for group",
            date = Timestamp(calendar.time),
            participants = listOf("user1"),
            maxParticipants = 10,
            visibility = Visibility.PUBLIC,
            eventIds = listOf(eventId),
            ownerId = "owner1",
            groupId = groupId)
    serieRepo.addTestSerie(serie)

    // Create event
    val event =
        Event(
            eventId = eventId,
            ownerId = "owner1",
            title = "Group Event",
            type = eventType,
            description = "Event in group serie",
            location = Location(46.52, 6.63, "EPFL"),
            date = Timestamp(calendar.time),
            duration = 90,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            groupId = groupId)
    eventRepo.addTestEvent(event)

    val viewModel = EditEventForSerieViewModel(eventRepo, serieRepo, groupRepo)
    composeTestRule.setContent {
      EditEventForSerieScreen(
          serieId = serieId, eventId = eventId, editEventForSerieViewModel = viewModel)
    }

    composeTestRule.waitForIdle()
    composeTestRule.mainClock.advanceTimeBy(2000)
    composeTestRule.waitForIdle()

    return Triple(eventRepo, serieRepo, groupRepo)
  }

  @Test
  fun groupSerieEvent_typeFieldIsReadOnlyAndCanEditOtherFields() {
    // Setup with SPORTS group
    setupGroupSerieEventScreen(EventType.SPORTS, "group-1", "serie-1", "event-1")

    // Verify type field shows as read-only text
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TYPE)
        .assertTextContains("SPORTS")

    // Verify dropdown doesn't open when clicked
    composeTestRule.onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TYPE).performClick()
    composeTestRule.waitForIdle()
    composeTestRule.onNodeWithText("ACTIVITY").assertDoesNotExist()
    composeTestRule.onNodeWithText("SOCIAL").assertDoesNotExist()

    // Verify other fields can be edited
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TITLE)
        .performTextClearance()
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TITLE)
        .performTextInput("Updated Title")

    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_DESCRIPTION)
        .performTextClearance()
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_DESCRIPTION)
        .performTextInput("Updated Description")

    composeTestRule.waitForIdle()

    // Verify edits persisted but type remains unchanged
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TITLE)
        .assertTextContains("Updated Title")
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_DESCRIPTION)
        .assertTextContains("Updated Description")
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TYPE)
        .assertTextContains("SPORTS")
  }

  @Test
  fun standaloneSerieEvent_typeFieldIsEditableDropdown() {
    val eventRepo = FakeEventsRepository()
    val serieRepo = FakeSeriesRepository()
    val groupRepo = FakeGroupRepository()

    val calendar = Calendar.getInstance()
    calendar.set(2025, Calendar.DECEMBER, 25, 14, 30, 0)

    // Create serie WITHOUT a group
    val serie =
        Serie(
            serieId = "serie-standalone",
            title = "Standalone Serie",
            description = "Serie without group",
            date = Timestamp(calendar.time),
            participants = listOf("user1"),
            maxParticipants = 10,
            visibility = Visibility.PUBLIC,
            eventIds = listOf("event-standalone"),
            ownerId = "owner1",
            groupId = null)
    serieRepo.addTestSerie(serie)

    val event =
        Event(
            eventId = "event-standalone",
            ownerId = "owner1",
            title = "Standalone Event",
            type = EventType.ACTIVITY,
            description = "Event in standalone serie",
            location = Location(46.52, 6.63, "Park"),
            date = Timestamp(calendar.time),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC)
    eventRepo.addTestEvent(event)

    val viewModel = EditEventForSerieViewModel(eventRepo, serieRepo, groupRepo)
    composeTestRule.setContent {
      EditEventForSerieScreen(
          serieId = "serie-standalone",
          eventId = "event-standalone",
          editEventForSerieViewModel = viewModel)
    }

    composeTestRule.waitForIdle()
    composeTestRule.mainClock.advanceTimeBy(2000)
    composeTestRule.waitForIdle()

    // Verify type field is editable dropdown
    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TYPE)
        .assertTextContains("ACTIVITY")
        .performClick()

    composeTestRule.waitForIdle()
    composeTestRule.mainClock.advanceTimeBy(500)
    composeTestRule.waitForIdle()

    // Verify dropdown options appear and can be selected
    composeTestRule.onNodeWithText("SPORTS").assertExists().performClick()
    composeTestRule.waitForIdle()

    composeTestRule
        .onNodeWithTag(EditEventForSerieScreenTestTags.INPUT_EVENT_TYPE)
        .assertTextContains("SPORTS")
  }
}
