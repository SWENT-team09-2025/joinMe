package com.android.joinme.ui.overview

import com.android.joinme.model.event.Event
import com.android.joinme.model.event.EventFilter
import com.android.joinme.model.event.EventType
import com.android.joinme.model.event.EventVisibility
import com.android.joinme.model.event.EventsRepository
import com.android.joinme.model.map.Location
import com.android.joinme.model.map.LocationRepository
import com.android.joinme.model.serie.Serie
import com.android.joinme.model.serie.SeriesRepository
import com.android.joinme.model.utils.Visibility
import com.google.firebase.Timestamp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

/** Note: The tests were generated by IA (Claude) */

/**
 * Unit tests for EditEventForSerieViewModel.
 *
 * Tests the edit event for serie functionality, including:
 * - Loading existing event data into the form
 * - Editing event fields
 * - Duration change cascade logic (updating subsequent events)
 * - Error handling
 */
@OptIn(ExperimentalCoroutinesApi::class)
class EditEventForSerieViewModelTest {

  // ---- Fake Repositories ----

  private class FakeLocationRepository : LocationRepository {
    override suspend fun search(query: String): List<Location> {
      return if (query.isBlank()) {
        emptyList()
      } else {
        listOf(
            Location(latitude = 1.0, longitude = 1.0, name = "Location 1"),
            Location(latitude = 2.0, longitude = 2.0, name = "Location 2"))
      }
    }
  }

  private class FakeEventsRepository : EventsRepository {
    private val events = mutableMapOf<String, Event>()
    var shouldThrowError = false

    fun addTestEvent(event: Event) {
      events[event.eventId] = event
    }

    override suspend fun getEvent(eventId: String): Event {
      if (shouldThrowError) throw RuntimeException("Network error")
      return events[eventId] ?: throw NoSuchElementException("Event not found")
    }

    override suspend fun getAllEvents(filter: EventFilter): List<Event> {
      if (shouldThrowError) throw RuntimeException("Network error")
      return events.values.toList()
    }

    override suspend fun editEvent(eventId: String, event: Event) {
      if (shouldThrowError) throw RuntimeException("Network error")
      events[eventId] = event
    }

    override suspend fun addEvent(event: Event) {
      events[event.eventId] = event
    }

    override fun getNewEventId(): String = "newId"

    override suspend fun deleteEvent(eventId: String) {
      events.remove(eventId)
    }

    override suspend fun getEventsByIds(eventIds: List<String>): List<Event> {
      events
          .filter { eventIds.contains(it.key) }
          .let {
            return it.values.toList().sortedBy { event -> event.date.toDate().time }
          }
    }

    override suspend fun getCommonEvents(userIds: List<String>): List<Event> {
      if (shouldThrowError) throw RuntimeException("Network error")
      if (userIds.isEmpty()) return emptyList()
      return events.values
          .filter { event -> userIds.all { userId -> event.participants.contains(userId) } }
          .sortedBy { it.date.toDate().time }
    }
  }

  private class FakeSeriesRepository : SeriesRepository {
    private val series = mutableMapOf<String, Serie>()
    var shouldThrowError = false

    fun addTestSerie(serie: Serie) {
      series[serie.serieId] = serie
    }

    override suspend fun getSerie(serieId: String): Serie {
      if (shouldThrowError) throw RuntimeException("Network error")
      return series[serieId] ?: throw NoSuchElementException("Serie not found")
    }

    override suspend fun editSerie(serieId: String, serie: Serie) {
      if (shouldThrowError) throw RuntimeException("Network error")
      series[serieId] = serie
    }

    override suspend fun addSerie(serie: Serie) {
      series[serie.serieId] = serie
    }

    override suspend fun deleteSerie(serieId: String) {
      series.remove(serieId)
    }

    override suspend fun getAllSeries(
        filter: com.android.joinme.model.serie.SerieFilter
    ): List<Serie> {
      return series.values.toList()
    }

    override suspend fun getSeriesByIds(seriesIds: List<String>): List<Serie> {
      series
          .filter { seriesIds.contains(it.key) }
          .let {
            return it.values.toList()
          }
    }

    override fun getNewSerieId(): String = "newSerieId"
  }

  private lateinit var locationRepo: FakeLocationRepository
  private lateinit var eventRepo: FakeEventsRepository
  private lateinit var serieRepo: FakeSeriesRepository
  private lateinit var vm: EditEventForSerieViewModel
  private val testDispatcher = StandardTestDispatcher()

  @Before
  fun setUp() {
    Dispatchers.setMain(testDispatcher)
    locationRepo = FakeLocationRepository()
    eventRepo = FakeEventsRepository()
    serieRepo = FakeSeriesRepository()
    vm = EditEventForSerieViewModel(eventRepo, serieRepo, locationRepo)
  }

  @After
  fun tearDown() {
    Dispatchers.resetMain()
  }

  // ---------- Load Event ----------

  @Test
  fun loadEvent_populatesUIStateWithEventData() = runTest {
    val location = Location(latitude = 46.52, longitude = 6.57, name = "EPFL")
    val event =
        Event(
            eventId = "event1",
            type = EventType.SPORTS,
            title = "Soccer Match",
            description = "Weekly soccer",
            location = location,
            date = Timestamp.now(),
            duration = 90,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            ownerId = "user1")
    eventRepo.addTestEvent(event)

    vm.loadEvent("event1")
    advanceUntilIdle()

    val state = vm.uiState.value
    assertEquals("SPORTS", state.type)
    assertEquals("Soccer Match", state.title)
    assertEquals("Weekly soccer", state.description)
    assertEquals("EPFL", state.location)
    assertEquals("EPFL", state.locationQuery)
    assertEquals(location, state.selectedLocation)
    assertEquals("90", state.duration)
  }

  @Test
  fun loadEvent_withNullLocation_setsEmptyLocationFields() = runTest {
    val event =
        Event(
            eventId = "event1",
            type = EventType.ACTIVITY,
            title = "Activity",
            description = "Description",
            location = null,
            date = Timestamp.now(),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 5,
            visibility = EventVisibility.PRIVATE,
            ownerId = "user1")
    eventRepo.addTestEvent(event)

    vm.loadEvent("event1")
    advanceUntilIdle()

    val state = vm.uiState.value
    assertEquals("", state.location)
    assertEquals("", state.locationQuery)
    assertNull(state.selectedLocation)
  }

  @Test
  fun loadEvent_error_setsErrorMessage() = runTest {
    eventRepo.shouldThrowError = true

    vm.loadEvent("event1")
    advanceUntilIdle()

    assertNotNull(vm.uiState.value.errorMsg)
    assertTrue(vm.uiState.value.errorMsg!!.contains("Failed to load event"))
  }

  // ---------- Edit Event - Basic ----------

  @Test
  fun editEventForSerie_withValidData_updatesEvent() = runTest {
    val location = Location(latitude = 1.0, longitude = 1.0, name = "Stadium")
    val newLocation = Location(latitude = 2.0, longitude = 2.0, name = "Arena")
    val event =
        Event(
            eventId = "event1",
            type = EventType.SPORTS,
            title = "Old Title",
            description = "Old Description",
            location = location,
            date = Timestamp.now(),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            ownerId = "user1")
    eventRepo.addTestEvent(event)

    val serie =
        Serie(
            serieId = "serie1",
            title = "Serie",
            description = "Description",
            date = Timestamp.now(),
            participants = listOf("user1"),
            maxParticipants = 10,
            visibility = Visibility.PUBLIC,
            eventIds = listOf("event1"),
            ownerId = "user1")
    serieRepo.addTestSerie(serie)

    // Set new values
    vm.setType("ACTIVITY")
    vm.setTitle("New Title")
    vm.setDescription("New Description")
    vm.setDuration("90")
    vm.selectLocation(newLocation)

    val success = vm.editEventForSerie("serie1", "event1")
    advanceUntilIdle()

    assertTrue(success)
    val updatedEvent = eventRepo.getEvent("event1")
    assertEquals(EventType.ACTIVITY, updatedEvent.type)
    assertEquals("New Title", updatedEvent.title)
    assertEquals("New Description", updatedEvent.description)
    assertEquals(newLocation, updatedEvent.location)
    assertEquals(90, updatedEvent.duration)
  }

  @Test
  fun editEventForSerie_invalidState_returnsFalse() = runTest {
    // Don't set any fields - state will be invalid
    val success = vm.editEventForSerie("serie1", "event1")

    assertFalse(success)
    assertNotNull(vm.uiState.value.errorMsg)
    assertTrue(vm.uiState.value.errorMsg!!.contains("not valid"))
  }

  @Test
  fun editEventForSerie_error_returnsFalseAndSetsErrorMsg() = runTest {
    val location = Location(latitude = 1.0, longitude = 1.0, name = "Stadium")
    vm.setType("SPORTS")
    vm.setTitle("Title")
    vm.setDescription("Description")
    vm.setDuration("60")
    vm.selectLocation(location)

    eventRepo.shouldThrowError = true

    val success = vm.editEventForSerie("serie1", "event1")

    assertFalse(success)
    assertNotNull(vm.uiState.value.errorMsg)
    assertTrue(vm.uiState.value.errorMsg!!.contains("Failed to edit event"))
  }

  // ---------- Duration Change - Cascade Logic ----------

  @Test
  fun editEventForSerie_durationIncreased_updatesSubsequentEvents() = runTest {
    // Create 3 events in a serie
    // Event1: starts at time 0, duration 60 min
    // Event2: starts at time 60, duration 60 min
    // Event3: starts at time 120, duration 60 min
    val baseTime = 1000000000000L
    val event1 =
        Event(
            eventId = "event1",
            type = EventType.SPORTS,
            title = "Event 1",
            description = "Desc",
            location = Location(1.0, 1.0, "Stadium"),
            date = Timestamp(java.util.Date(baseTime)),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            ownerId = "user1")
    val event2 =
        Event(
            eventId = "event2",
            type = EventType.SPORTS,
            title = "Event 2",
            description = "Desc",
            location = Location(1.0, 1.0, "Stadium"),
            date = Timestamp(java.util.Date(baseTime + 60 * 60 * 1000)),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            ownerId = "user1")
    val event3 =
        Event(
            eventId = "event3",
            type = EventType.SPORTS,
            title = "Event 3",
            description = "Desc",
            location = Location(1.0, 1.0, "Stadium"),
            date = Timestamp(java.util.Date(baseTime + 120 * 60 * 1000)),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            ownerId = "user1")

    eventRepo.addTestEvent(event1)
    eventRepo.addTestEvent(event2)
    eventRepo.addTestEvent(event3)

    val serie =
        Serie(
            serieId = "serie1",
            title = "Serie",
            description = "Description",
            date = Timestamp(java.util.Date(baseTime)),
            participants = listOf("user1"),
            maxParticipants = 10,
            visibility = Visibility.PUBLIC,
            eventIds = listOf("event1", "event2", "event3"),
            ownerId = "user1")
    serieRepo.addTestSerie(serie)

    // Edit event1: increase duration from 60 to 90 (30 min increase)
    vm.loadEvent("event1")
    advanceUntilIdle()
    vm.setDuration("90")

    val success = vm.editEventForSerie("serie1", "event1")
    advanceUntilIdle()

    assertTrue(success)

    // Event1 should have new duration
    val updatedEvent1 = eventRepo.getEvent("event1")
    assertEquals(90, updatedEvent1.duration)

    // Event2 should start 30 min later
    val updatedEvent2 = eventRepo.getEvent("event2")
    val expectedEvent2Time = baseTime + 90 * 60 * 1000 // event1 now ends 30 min later
    assertEquals(expectedEvent2Time, updatedEvent2.date.toDate().time)

    // Event3 should also start 30 min later
    val updatedEvent3 = eventRepo.getEvent("event3")
    val expectedEvent3Time = baseTime + 150 * 60 * 1000 // event2 starts 30 min later
    assertEquals(expectedEvent3Time, updatedEvent3.date.toDate().time)
  }

  @Test
  fun editEventForSerie_durationDecreased_updatesSubsequentEvents() = runTest {
    // Create 2 events
    // Event1: starts at time 0, duration 120 min
    // Event2: starts at time 120, duration 60 min
    val baseTime = 1000000000000L
    val event1 =
        Event(
            eventId = "event1",
            type = EventType.SPORTS,
            title = "Event 1",
            description = "Desc",
            location = Location(1.0, 1.0, "Stadium"),
            date = Timestamp(java.util.Date(baseTime)),
            duration = 120,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            ownerId = "user1")
    val event2 =
        Event(
            eventId = "event2",
            type = EventType.SPORTS,
            title = "Event 2",
            description = "Desc",
            location = Location(1.0, 1.0, "Stadium"),
            date = Timestamp(java.util.Date(baseTime + 120 * 60 * 1000)),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            ownerId = "user1")

    eventRepo.addTestEvent(event1)
    eventRepo.addTestEvent(event2)

    val serie =
        Serie(
            serieId = "serie1",
            title = "Serie",
            description = "Description",
            date = Timestamp(java.util.Date(baseTime)),
            participants = listOf("user1"),
            maxParticipants = 10,
            visibility = Visibility.PUBLIC,
            eventIds = listOf("event1", "event2"),
            ownerId = "user1")
    serieRepo.addTestSerie(serie)

    // Edit event1: decrease duration from 120 to 60 (60 min decrease)
    vm.loadEvent("event1")
    advanceUntilIdle()
    vm.setDuration("60")

    val success = vm.editEventForSerie("serie1", "event1")
    advanceUntilIdle()

    assertTrue(success)

    // Event1 should have new duration
    val updatedEvent1 = eventRepo.getEvent("event1")
    assertEquals(60, updatedEvent1.duration)

    // Event2 should start 60 min earlier
    val updatedEvent2 = eventRepo.getEvent("event2")
    val expectedEvent2Time = baseTime + 60 * 60 * 1000 // event1 now ends 60 min earlier
    assertEquals(expectedEvent2Time, updatedEvent2.date.toDate().time)
  }

  @Test
  fun editEventForSerie_durationUnchanged_doesNotUpdateSubsequentEvents() = runTest {
    val baseTime = 1000000000000L
    val event1 =
        Event(
            eventId = "event1",
            type = EventType.SPORTS,
            title = "Event 1",
            description = "Desc",
            location = Location(1.0, 1.0, "Stadium"),
            date = Timestamp(java.util.Date(baseTime)),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            ownerId = "user1")
    val event2 =
        Event(
            eventId = "event2",
            type = EventType.SPORTS,
            title = "Event 2",
            description = "Desc",
            location = Location(1.0, 1.0, "Stadium"),
            date = Timestamp(java.util.Date(baseTime + 60 * 60 * 1000)),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            ownerId = "user1")

    eventRepo.addTestEvent(event1)
    eventRepo.addTestEvent(event2)

    val serie =
        Serie(
            serieId = "serie1",
            title = "Serie",
            description = "Description",
            date = Timestamp(java.util.Date(baseTime)),
            participants = listOf("user1"),
            maxParticipants = 10,
            visibility = Visibility.PUBLIC,
            eventIds = listOf("event1", "event2"),
            ownerId = "user1")
    serieRepo.addTestSerie(serie)

    // Edit event1 but keep duration the same (60 min)
    vm.loadEvent("event1")
    advanceUntilIdle()
    vm.setTitle("New Title") // Change something else

    val success = vm.editEventForSerie("serie1", "event1")
    advanceUntilIdle()

    assertTrue(success)

    // Event2 should have the same date (not shifted)
    val updatedEvent2 = eventRepo.getEvent("event2")
    assertEquals(baseTime + 60 * 60 * 1000, updatedEvent2.date.toDate().time)
  }

  @Test
  fun editEventForSerie_lastEventInSerie_noSubsequentEventsUpdated() = runTest {
    val baseTime = 1000000000000L
    val event1 =
        Event(
            eventId = "event1",
            type = EventType.SPORTS,
            title = "Event 1",
            description = "Desc",
            location = Location(1.0, 1.0, "Stadium"),
            date = Timestamp(java.util.Date(baseTime)),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            ownerId = "user1")

    eventRepo.addTestEvent(event1)

    val serie =
        Serie(
            serieId = "serie1",
            title = "Serie",
            description = "Description",
            date = Timestamp(java.util.Date(baseTime)),
            participants = listOf("user1"),
            maxParticipants = 10,
            visibility = Visibility.PUBLIC,
            eventIds = listOf("event1"),
            ownerId = "user1")
    serieRepo.addTestSerie(serie)

    // Edit the only event - no subsequent events to update
    vm.loadEvent("event1")
    advanceUntilIdle()
    vm.setDuration("90")

    val success = vm.editEventForSerie("serie1", "event1")
    advanceUntilIdle()

    assertTrue(success)
    val updatedEvent1 = eventRepo.getEvent("event1")
    assertEquals(90, updatedEvent1.duration)
  }

  @Test
  fun editEventForSerie_middleEvent_onlyUpdatesSubsequentEvents() = runTest {
    // Create 3 events, edit the middle one
    val baseTime = 1000000000000L
    val event1 =
        Event(
            eventId = "event1",
            type = EventType.SPORTS,
            title = "Event 1",
            description = "Desc",
            location = Location(1.0, 1.0, "Stadium"),
            date = Timestamp(java.util.Date(baseTime)),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            ownerId = "user1")
    val event2 =
        Event(
            eventId = "event2",
            type = EventType.SPORTS,
            title = "Event 2",
            description = "Desc",
            location = Location(1.0, 1.0, "Stadium"),
            date = Timestamp(java.util.Date(baseTime + 60 * 60 * 1000)),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            ownerId = "user1")
    val event3 =
        Event(
            eventId = "event3",
            type = EventType.SPORTS,
            title = "Event 3",
            description = "Desc",
            location = Location(1.0, 1.0, "Stadium"),
            date = Timestamp(java.util.Date(baseTime + 120 * 60 * 1000)),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            ownerId = "user1")

    eventRepo.addTestEvent(event1)
    eventRepo.addTestEvent(event2)
    eventRepo.addTestEvent(event3)

    val serie =
        Serie(
            serieId = "serie1",
            title = "Serie",
            description = "Description",
            date = Timestamp(java.util.Date(baseTime)),
            participants = listOf("user1"),
            maxParticipants = 10,
            visibility = Visibility.PUBLIC,
            eventIds = listOf("event1", "event2", "event3"),
            ownerId = "user1")
    serieRepo.addTestSerie(serie)

    // Edit event2 (middle): increase duration from 60 to 120 (60 min increase)
    vm.loadEvent("event2")
    advanceUntilIdle()
    vm.setDuration("120")

    val success = vm.editEventForSerie("serie1", "event2")
    advanceUntilIdle()

    assertTrue(success)

    // Event1 should be unchanged
    val updatedEvent1 = eventRepo.getEvent("event1")
    assertEquals(baseTime, updatedEvent1.date.toDate().time)
    assertEquals(60, updatedEvent1.duration)

    // Event2 should have new duration
    val updatedEvent2 = eventRepo.getEvent("event2")
    assertEquals(120, updatedEvent2.duration)

    // Event3 should start 60 min later
    val updatedEvent3 = eventRepo.getEvent("event3")
    val expectedEvent3Time = baseTime + 180 * 60 * 1000 // event2 now ends 60 min later
    assertEquals(expectedEvent3Time, updatedEvent3.date.toDate().time)
  }

  // ---------- Serie lastEventEndTime Update ----------

  @Test
  fun editEventForSerie_durationChanged_updatesSerieLastEventEndTime() = runTest {
    // Create a serie with 2 events
    val baseTime = 1000000000000L
    val event1 =
        Event(
            eventId = "event1",
            type = EventType.SPORTS,
            title = "Event 1",
            description = "Desc",
            location = Location(1.0, 1.0, "Stadium"),
            date = Timestamp(java.util.Date(baseTime)),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            ownerId = "user1")
    val event2 =
        Event(
            eventId = "event2",
            type = EventType.SPORTS,
            title = "Event 2",
            description = "Desc",
            location = Location(1.0, 1.0, "Stadium"),
            date = Timestamp(java.util.Date(baseTime + 60 * 60 * 1000)),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            ownerId = "user1")

    eventRepo.addTestEvent(event1)
    eventRepo.addTestEvent(event2)

    val serie =
        Serie(
            serieId = "serie1",
            title = "Serie",
            description = "Description",
            date = Timestamp(java.util.Date(baseTime)),
            participants = listOf("user1"),
            maxParticipants = 10,
            visibility = Visibility.PUBLIC,
            eventIds = listOf("event1", "event2"),
            ownerId = "user1")
    serieRepo.addTestSerie(serie)

    // Edit event2: increase duration from 60 to 90 (30 min increase)
    vm.loadEvent("event2")
    advanceUntilIdle()
    vm.setDuration("90")

    val success = vm.editEventForSerie("serie1", "event2")
    advanceUntilIdle()

    assertTrue(success)

    // Serie's lastEventEndTime should be updated to event2's new end time
    val updatedSerie = serieRepo.getSerie("serie1")
    val expectedLastEventEndTime = baseTime + 60 * 60 * 1000 + 90 * 60 * 1000
    assertEquals(expectedLastEventEndTime, updatedSerie.lastEventEndTime?.toDate()?.time)
  }

  @Test
  fun editEventForSerie_singleEvent_updatesLastEventEndTimeOnlyWhenDurationChanges() = runTest {
    // Test that lastEventEndTime is updated when duration changes, but not when only other fields
    // change
    val baseTime = 1000000000000L
    val event1 =
        Event(
            eventId = "event1",
            type = EventType.SPORTS,
            title = "Event 1",
            description = "Desc",
            location = Location(1.0, 1.0, "Stadium"),
            date = Timestamp(java.util.Date(baseTime)),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            ownerId = "user1")

    eventRepo.addTestEvent(event1)

    val initialLastEventEndTime = Timestamp(java.util.Date(baseTime + 60 * 60 * 1000))
    val serie =
        Serie(
            serieId = "serie1",
            title = "Serie",
            description = "Description",
            date = Timestamp(java.util.Date(baseTime)),
            participants = listOf("user1"),
            maxParticipants = 10,
            visibility = Visibility.PUBLIC,
            eventIds = listOf("event1"),
            ownerId = "user1")
    serieRepo.addTestSerie(serie.copy(lastEventEndTime = initialLastEventEndTime))

    // First: Edit duration from 60 to 120
    vm.loadEvent("event1")
    advanceUntilIdle()
    vm.setDuration("120")

    var success = vm.editEventForSerie("serie1", "event1")
    advanceUntilIdle()

    assertTrue(success)

    // Serie's lastEventEndTime should be updated to event1's new end time
    var updatedSerie = serieRepo.getSerie("serie1")
    val expectedLastEventEndTime = baseTime + 120 * 60 * 1000
    assertEquals(expectedLastEventEndTime, updatedSerie.lastEventEndTime?.toDate()?.time)

    // Second: Edit title only (duration remains 120)
    vm.loadEvent("event1")
    advanceUntilIdle()
    vm.setTitle("New Title")

    success = vm.editEventForSerie("serie1", "event1")
    advanceUntilIdle()

    assertTrue(success)

    // Serie's lastEventEndTime should remain unchanged (still 120 min after start)
    updatedSerie = serieRepo.getSerie("serie1")
    assertEquals(expectedLastEventEndTime, updatedSerie.lastEventEndTime?.toDate()?.time)
  }

  // ---------- Loading State ----------

  @Test
  fun editEventForSerie_setsLoadingStateDuringOperation() = runTest {
    val location = Location(latitude = 1.0, longitude = 1.0, name = "Stadium")
    val event =
        Event(
            eventId = "event1",
            type = EventType.SPORTS,
            title = "Title",
            description = "Description",
            location = location,
            date = Timestamp.now(),
            duration = 60,
            participants = emptyList(),
            maxParticipants = 10,
            visibility = EventVisibility.PUBLIC,
            ownerId = "user1")
    eventRepo.addTestEvent(event)

    val serie =
        Serie(
            serieId = "serie1",
            title = "Serie",
            description = "Description",
            date = Timestamp.now(),
            participants = listOf("user1"),
            maxParticipants = 10,
            visibility = Visibility.PUBLIC,
            eventIds = listOf("event1"),
            ownerId = "user1")
    serieRepo.addTestSerie(serie)

    vm.loadEvent("event1")
    advanceUntilIdle()

    val success = vm.editEventForSerie("serie1", "event1")
    advanceUntilIdle()

    assertTrue(success)
    assertFalse(vm.uiState.value.isLoading) // Should be false after completion
  }
}
