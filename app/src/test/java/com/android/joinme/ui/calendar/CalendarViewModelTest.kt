package com.android.joinme.ui.calendar

import com.android.joinme.model.event.Event
import com.android.joinme.model.event.EventFilter
import com.android.joinme.model.event.EventType
import com.android.joinme.model.event.EventVisibility
import com.android.joinme.model.event.EventsRepository
import com.android.joinme.model.eventItem.EventItem
import com.android.joinme.model.serie.Serie
import com.android.joinme.model.serie.SerieFilter
import com.android.joinme.model.serie.SeriesRepository
import com.android.joinme.model.utils.Visibility
import com.google.firebase.Timestamp
import java.util.Calendar
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNotNull
import org.junit.Assert.assertNull
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test

/** Note: this file was generated by AI (Claude). */

/**
 * Unit tests for [CalendarViewModel].
 *
 * Verifies UI state updates, date selection, month navigation, and error handling.
 */
@OptIn(ExperimentalCoroutinesApi::class)
class CalendarViewModelTest {

  private val testDispatcher = StandardTestDispatcher()

  private lateinit var fakeEventRepository: FakeEventsRepository
  private lateinit var fakeSerieRepository: FakeSeriesRepository
  private lateinit var viewModel: CalendarViewModel

  @Before
  fun setup() {
    Dispatchers.setMain(testDispatcher)
    fakeEventRepository = FakeEventsRepository()
    fakeSerieRepository = FakeSeriesRepository()
    viewModel =
        CalendarViewModel(
            eventsRepository = fakeEventRepository, seriesRepository = fakeSerieRepository)
  }

  @After
  fun tearDown() {
    Dispatchers.resetMain()
  }

  private fun advanceAndWait() = testDispatcher.scheduler.advanceUntilIdle()

  private fun createErrorViewModel(): CalendarViewModel {
    fakeEventRepository.shouldThrow = true
    return CalendarViewModel(
        eventsRepository = fakeEventRepository, seriesRepository = fakeSerieRepository)
  }

  @Test
  fun `initial state is correctly set`() {
    val state = viewModel.uiState.value
    val calendar = Calendar.getInstance()

    assertTrue(state.selectedDate > 0)
    assertTrue(state.itemsForDate.isEmpty())
    assertEquals(calendar.get(Calendar.MONTH), state.currentMonth)
    assertEquals(calendar.get(Calendar.YEAR), state.currentYear)
  }

  @Test
  fun `loadAllItems loads events and series successfully and isLoading transitions correctly`() =
      runTest {
        advanceAndWait()

        val state = viewModel.uiState.value
        assertNull(state.error)
        assertEquals(false, state.isLoading)
      }

  @Test
  fun `loadAllItems handles repository failure and sets error state`() = runTest {
    val failingViewModel = createErrorViewModel()
    advanceAndWait()

    val state = failingViewModel.uiState.value
    assertNotNull(state.error)
    assertTrue(state.error!!.contains("Failed to load items"))
    assertEquals(false, state.isLoading)
  }

  @Test
  fun `selectDate updates selected date and filters items correctly`() = runTest {
    advanceAndWait()

    val tomorrowCalendar = Calendar.getInstance().apply { add(Calendar.DAY_OF_MONTH, 1) }
    viewModel.selectDate(tomorrowCalendar.timeInMillis)
    assertEquals(tomorrowCalendar.timeInMillis, viewModel.uiState.value.selectedDate)

    assertTrue(viewModel.uiState.value.itemsForDate.any { it.title == "Tomorrow Event" })
    assertTrue(viewModel.uiState.value.itemsForDate.none { it.title == "Today Event" })

    val todayCalendar = Calendar.getInstance()
    viewModel.selectDate(todayCalendar.timeInMillis)
    assertTrue(viewModel.uiState.value.itemsForDate.any { it.title == "Today Event" })
  }

  @Test
  fun `month navigation works correctly`() = runTest {
    advanceAndWait()

    viewModel.changeMonth(5, 2025) // June 2025
    assertEquals(5, viewModel.uiState.value.currentMonth)
    assertEquals(2025, viewModel.uiState.value.currentYear)

    viewModel.nextMonth()
    assertEquals(6, viewModel.uiState.value.currentMonth) // July
    assertEquals(2025, viewModel.uiState.value.currentYear)

    viewModel.changeMonth(11, 2024) // December 2024
    viewModel.nextMonth()
    assertEquals(0, viewModel.uiState.value.currentMonth) // January
    assertEquals(2025, viewModel.uiState.value.currentYear)

    viewModel.changeMonth(5, 2025) // June 2025
    viewModel.previousMonth()
    assertEquals(4, viewModel.uiState.value.currentMonth) // May
    assertEquals(2025, viewModel.uiState.value.currentYear)

    viewModel.changeMonth(0, 2025) // January 2025
    viewModel.previousMonth()
    assertEquals(11, viewModel.uiState.value.currentMonth) // December
    assertEquals(2024, viewModel.uiState.value.currentYear)
  }

  @Test
  fun `daysWithItems tracks days with events correctly and is empty when no events`() = runTest {
    advanceAndWait()

    val calendar = Calendar.getInstance()
    viewModel.changeMonth(calendar.get(Calendar.MONTH), calendar.get(Calendar.YEAR))
    val today = calendar.get(Calendar.DAY_OF_MONTH)
    assertTrue(viewModel.uiState.value.daysWithItems.contains(today))

    val nextMonth = Calendar.getInstance().apply { add(Calendar.MONTH, 1) }
    viewModel.changeMonth(nextMonth.get(Calendar.MONTH), nextMonth.get(Calendar.YEAR))
    val nextMonthDay = nextMonth.get(Calendar.DAY_OF_MONTH)
    assertTrue(viewModel.uiState.value.daysWithItems.contains(nextMonthDay))

    // Test empty month
    fakeEventRepository.clearAllEvents()
    fakeSerieRepository.clearAllSeries()
    val emptyViewModel =
        CalendarViewModel(
            eventsRepository = fakeEventRepository, seriesRepository = fakeSerieRepository)
    advanceAndWait()
    emptyViewModel.changeMonth(0, 2020)
    assertTrue(emptyViewModel.uiState.value.daysWithItems.isEmpty())
  }

  @Test
  fun `refreshItems reloads data from repositories`() = runTest {
    advanceAndWait()

    fakeEventRepository.addNewEvent()
    viewModel.refreshItems()
    advanceAndWait()

    assertNull(viewModel.uiState.value.error)
  }

  @Test
  fun `clearError clears error state`() = runTest {
    val failingViewModel = createErrorViewModel()
    advanceAndWait()

    assertNotNull(failingViewModel.uiState.value.error)

    failingViewModel.clearError()

    assertNull(failingViewModel.uiState.value.error)
  }

  @Test
  fun `isLoading state during refresh`() = runTest {
    fakeEventRepository.setDelay(1000)
    viewModel.refreshItems()
    testDispatcher.scheduler.runCurrent()
    assertEquals(true, viewModel.uiState.value.isLoading)

    advanceAndWait()
    assertEquals(false, viewModel.uiState.value.isLoading)
  }

  @Test
  fun `items are sorted by time for selected date`() = runTest {
    fakeEventRepository.addMultipleEventsOnSameDay()
    advanceAndWait()

    val calendar = Calendar.getInstance().apply { add(Calendar.DAY_OF_MONTH, 5) }
    viewModel.selectDate(calendar.timeInMillis)

    val items = viewModel.uiState.value.itemsForDate
    for (i in 0 until items.size - 1) {
      assertTrue(items[i].date.toDate().time <= items[i + 1].date.toDate().time)
    }
  }

  @Test
  fun `event items are correctly typed and series events are excluded`() = runTest {
    advanceAndWait()

    viewModel.selectDate(Calendar.getInstance().timeInMillis)
    val state = viewModel.uiState.value

    assertTrue(state.itemsForDate.filterIsInstance<EventItem.SingleEvent>().isNotEmpty())
    assertTrue(state.itemsForDate.filterIsInstance<EventItem.EventSerie>().isNotEmpty())

    fakeSerieRepository.addSerieWithEvents()
    viewModel.refreshItems()
    advanceAndWait()
    val updatedSingleEvents =
        viewModel.uiState.value.itemsForDate.filterIsInstance<EventItem.SingleEvent>()
    updatedSingleEvents.forEach { item -> assertTrue(item.title != "Event In Serie") }
  }

  /** Fake implementation of [EventsRepository] for isolated ViewModel testing. */
  private class FakeEventsRepository : EventsRepository {
    var shouldThrow = false
    private var delayMillis: Long = 0
    private val fakeEvents = mutableListOf<Event>()

    fun setDelay(millis: Long) {
      delayMillis = millis
    }

    init {
      fakeEvents.add(createEvent("1", "Today Event", 0, 10, EventType.SPORTS))
      fakeEvents.add(createEvent("2", "Tomorrow Event", 1, 14, EventType.SOCIAL))
      fakeEvents.add(createEvent("3", "Next Month Event", 30, 9, EventType.ACTIVITY))
    }

    private fun createEvent(
        id: String,
        title: String,
        daysOffset: Int,
        hour: Int,
        type: EventType
    ): Event {
      val calendar =
          Calendar.getInstance().apply {
            if (daysOffset >= 30) {
              add(Calendar.MONTH, 1)
            } else {
              add(Calendar.DAY_OF_MONTH, daysOffset)
            }
            set(Calendar.HOUR_OF_DAY, hour)
            set(Calendar.MINUTE, 0)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)
          }
      return Event(
          eventId = id,
          type = type,
          title = title,
          description = "Description for $title",
          location = null,
          date = Timestamp(calendar.time),
          duration = 60,
          participants = emptyList(),
          maxParticipants = 10,
          visibility = EventVisibility.PUBLIC,
          ownerId = "owner$id")
    }

    fun addMultipleEventsOnSameDay() {
      fakeEvents.add(createEvent("4", "Morning Event", 5, 9, EventType.SPORTS))
      fakeEvents.add(createEvent("5", "Afternoon Event", 5, 14, EventType.SOCIAL))
    }

    fun clearAllEvents() {
      fakeEvents.clear()
    }

    fun addNewEvent() {
      fakeEvents.add(createEvent("new_event", "New Event", 3, 10, EventType.ACTIVITY))
    }

    override suspend fun getAllEvents(eventFilter: EventFilter): List<Event> {
      if (delayMillis > 0) kotlinx.coroutines.delay(delayMillis)
      if (shouldThrow) throw RuntimeException("Repository error")
      return fakeEvents.toList()
    }

    override suspend fun getEvent(eventId: String): Event = throw NotImplementedError()

    override suspend fun addEvent(event: Event) = throw NotImplementedError()

    override suspend fun editEvent(eventId: String, newValue: Event) = throw NotImplementedError()

    override suspend fun deleteEvent(eventId: String) = throw NotImplementedError()

    override suspend fun getEventsByIds(eventIds: List<String>): List<Event> =
        throw NotImplementedError()

    override fun getNewEventId(): String = throw NotImplementedError()

    override suspend fun getCommonEvents(userIds: List<String>): List<Event> =
        throw NotImplementedError()
  }

  /** Fake implementation of [SeriesRepository] for isolated ViewModel testing. */
  private class FakeSeriesRepository : SeriesRepository {
    var shouldThrow = false
    private val fakeSeries = mutableListOf<Serie>()

    init {
      fakeSeries.add(createSerie("serie1", "Today Serie", 0, emptyList()))
    }

    private fun createSerie(
        id: String,
        title: String,
        daysOffset: Int,
        eventIds: List<String>
    ): Serie {
      val calendar =
          Calendar.getInstance().apply {
            add(Calendar.DAY_OF_MONTH, daysOffset)
            set(Calendar.HOUR_OF_DAY, 11)
            set(Calendar.MINUTE, 0)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)
          }
      val startDate = calendar.time
      calendar.add(Calendar.DAY_OF_MONTH, 7)
      val endDate = calendar.time

      return Serie(
          serieId = id,
          title = title,
          description = "Description for $title",
          date = Timestamp(startDate),
          participants = listOf("user1"),
          maxParticipants = 10,
          visibility = Visibility.PUBLIC,
          eventIds = eventIds,
          ownerId = "owner$id",
          lastEventEndTime = Timestamp(endDate))
    }

    fun clearAllSeries() = fakeSeries.clear()

    fun addSerieWithEvents() {
      fakeSeries.add(
          createSerie(
              "serie2", "Serie With Events", 2, listOf("event_in_serie_1", "event_in_serie_2")))
    }

    override fun getNewSerieId(): String = throw NotImplementedError()

    override suspend fun getAllSeries(serieFilter: SerieFilter): List<Serie> {
      if (shouldThrow) throw RuntimeException("Serie repository error")
      return fakeSeries.toList()
    }

    override suspend fun getSeriesByIds(seriesIds: List<String>): List<Serie> =
        throw NotImplementedError()

    override suspend fun getSerie(serieId: String): Serie = throw NotImplementedError()

    override suspend fun addSerie(serie: Serie) = throw NotImplementedError()

    override suspend fun editSerie(serieId: String, newValue: Serie) = throw NotImplementedError()

    override suspend fun deleteSerie(serieId: String) = throw NotImplementedError()
  }
}
